---
title: (算法) 查找树详解
date: 2020-11-01 11:53:09
categories: 算法
tags: 
  - 算法
  - 树
  - 查找
---

## 综述

分治思想是算法领域非常重要和常见的思路，而几乎所有的分治算法都可以转换成一颗树的结构。在查询问题中，这种树则一般被称为查找树。

查找树的优点在于查询效率较高，以二叉树为例，其平均时间复杂度为O(logn)，在查询海量数据时也可以拥有很不错的查询速度。

本章将会通过一步步的演进来详细阐述当前常见的几种查找树及其实现。包括普通二叉树，平衡二叉树，红黑树，B-TREE等。

树的搜索是一件很简单的事情，不论树的结构如何演进，搜索的方式都基本是一致的，不同的树，其差异主要在于树的构建过程，如何高效的构建出一个适合查找的树，才是查找树研究的重点

<!-- more -->

## 二叉树

二叉树的本质和二分查找是相同的。一棵理想的二叉树如下图所示：

![](bin-tree.png)

可以看到，树中的节点与数组中的元素其实是一一对应的，当我们从根节点开始查找元素，其顺序与我们在数组上使用二分查找是一样的。

构建一个二叉树也很简单，只要依照查找的顺序，依次在空位添加子节点即可，用代码实现如下：

``` Java
/*
public class TreeNode {
    int value;
    TreeNode left, right;
}
*/
public static TreeNode buildBinaryTree(Integer[] numbers) {
    TreeNode root = new TreeNode(numbers[0]);
    for (int i=1; i<numbers.length; i++) {
        TreeNode search = root;
        while(true) {
            if (numbers[i] > search.getValue()) {
                if (search.getRight()==null) {
                    search.setRight(new TreeNode(numbers[i]));
                    break;
                } else {
                    search = search.getRight();
                }
            } else {
                if (search.getLeft()==null) {
                    search.setLeft(new TreeNode(numbers[i]));
                    break;
                } else {
                    search = search.getLeft();
                }
            }
        }
    }
    return root;
}
```

二叉树的构建其实也是一种优化过的插入排序的过程，我们对一个数组进行任意的混淆，最后构建二叉树，对该树进行中序遍历，就可以得到一个已经排好序的有序数组。

```Java
public static void main(String[] args) {
    List<Integer> nums = Lists.newArrayList(7,2,1,6,5,4,3);
    Collections.shuffle(nums);
    TreeNode root = buildBinaryTree(nums.toArray(new Integer[]{}));
    DfsVisitor.midRoot(root);
}
/*
输出结果：
 1	 2	 3	 4	 5	 6	 7
*/
```

至此，我们其实可以看出，查找树的根本原理，首先是将所有的数据组成有序的结构，然后在这个有序结构上利用分治查找来提高查找效率。

二叉树虽然看起来很美好，但是存在着一个致命的问题：树结构的不平衡。这是由二叉树的构建过程决定的，构建的输入越有序，二叉树的查找效率反而越低。在极端情况下，假设输入是一个有序数列，那么二叉树就会退化成一个链表，查找则退化成了顺序查找。

![](bintree-array.png)

所以为了提高二叉树的搜索效率，我们必须尽量让构建出来的二叉树符合本节一开始图中所示的那种样子。即左右子树的节点深度尽量相同，这种理想二叉树就是平衡二叉树

## 平衡二叉树与AVL树

首先，来了解一下相关的定义：

```
平衡树，是指任意节点的子树的高度差都小于等于1。
每个节点最多有2个子节点的平衡树，则是平衡二叉树。
除此之外，只要满足定义的，比如B-Tree也是平衡树。

AVL树，是一种自平衡二叉查找树，其命名是由发明者的名字来命名的。
所以不要弄混，AVL树是一种平衡二叉查找树，但是不是所有的平衡二叉查找树都叫AVL树。
```

AVL树的插入与二叉树是一样的，但是重点在于插入之后，如果当前二叉树不是平衡二叉树，则会进行一次旋转操作，使树保持平衡。而如何进行旋转，是AVL树的灵魂。

在一棵平衡的二叉树上，连续向一颗子树下增加两次深度，就会造成原本二叉树的不平衡。例如现在有节点N，那么现在向N的左子树增加一个节点L,再向L的左子树增加一个节点LL，现在N的左右子树深度差超过了1(左2右0），就不再是平衡二叉树。以下将这种插入情况就称为`左左`插入。

根据简单的统计知识我们可以知道插入一共有四种情况：`左左、右右、左右、右左`。而实际上由于镜像的原因，本质上只有两种情况：

1. 同向插入，左左和右右。
2. 交叉插入，左右和右左。

而在AVL树种，有两种旋转方式：单旋和双旋，就分别对应这两种情况。

单旋是用来解决同向插入导致的不平衡场景，下面来看单旋的示意图：

![](avl_single_rotate.png)

对于单旋来说，解决问题主要在于子树的交换。因为原本的根节点n要在新的根节点l或r上占据一个子节点的位置。那么原本占据这个位置的子节点（子树）就要挂在n因为拆掉了l或r而空出的位置上。

这就是图中中间部分的红线和虚线表示出的交换过程，在断开根节点和子树的连接后，虚线的部分是要新增的连接，红线的部分是要删除的连接。

以图中右右插入为例，我们要将n节点接在r的左子树上，但是r的左子树已经有一个rl了，两个节点肯定就会有冲突。这时候因为r节点被提起来了，所以n节点的右子树正好空出来了，于是就可以把rl节点接在n节点的右子树上，以解决上面遇到的冲突问题。

---
未完待续......