---
title: (Mysql) 四、事务和锁
date: 2020-11-01 11:53:09
categories: Mysql
tags: 
  - MYSQL
  - 数据库
---

## 数据库的ACID原则

ACID是一组数据库设计原则，InnoDB完整的支持这种设计原则，其原则详情及InnoDB的实现方法如下列：

- A: 原子性，主要涉及事务(transaction)
- C: 一致性，主要涉及内部处理，包括双写缓存(doublewrite buffer)和崩溃恢复(crash recovery)功能。
- I: 隔离性，主要涉及事务(transaction)，尤其是事务的隔离级别。
- D: 持久性，很多时候与具体的硬件、网络环境相关。

在本章中，主要讨论InnoDB引擎中关于事务的实现，以及事务是如何保证原子性和隔离性的。

<!-- more -->
<!--
https://www.docs4dev.com/docs/zh/mysql/5.7/reference/innodb-transaction-isolation-levels.html
-->

## InnoDB事务隔离级别

事务隔离是隔离性的来源，不同的隔离级别设置可以在多个事务同事执行更改和查询时微调性能与结果的可靠性、一致性和可重复性之间的平衡。

InnoDB提供了`SQL:1992`规定的全部四个事务隔离级别：读未提交、读已提交、可重复读、序列化。其中InnoDB的默认隔离级别是可重复度。

下面将会根据隔离级别的层级详细描述不同的事务隔离级别的相关效果，每种隔离级别可以应对并发读取中的某一层次的错误，后面的隔离级别可以应对之前隔离界已经解决的错误。

### 读未提交与脏读

首先理解脏读。

当事务A插入了一个新数据R1，但是还没有提交时，查询B就可以查询到新数据R1，这种时候如果事务A回滚了，则会导致脏读的出现。查询B查询到了本不应该存在的数据R1。

而这种可以读取事务A`未提交`数据的隔离级别，就是`读未提交级别`。

在该级别下，数据库不使用任何锁来保证隔离性。

### 读已提交与幻读

如果要解决脏读问题，就需要至少采用`读已提交`级别的隔离级别。

要理解`读已提交`，首先需要了解一个知识点：一致的非锁定读取。

```
一致的非锁定读取
一致读是InnoDB在读已提交和可重复度隔离级别上SELECT语句的默认执行模式。
使用一致读取，数据库不会给对应的表上加锁，而是创建一个用于当前事务的快照。事务中的查询仅在快照中进行。
所以当事务执行期间，其它事务可以对表进行修改，而当前事务并不能查询到其它事务的修改结果。
```

在该级别中，在同一事务中，每个一致的读取都将设置并读取自己的新快照。

因为这种机制，一个事务A只能读取到`已经被提交`的数据，所以该级别被称为`读已提交`。

而对于锁定读取（包括带有`for update`或`lock in share mode`的`select`语句以及`update`,`delete`语句），InnoDB只会锁定索引记录，而不会锁定它们之间的间隙。

因为禁用了间隙锁定，在当前隔离级别下，可以在锁定记录的旁边自由插入新纪录，所以会导致`幻读`问题。

假设我们现在有一个表`TA`，其中`id`列为数字，我们目前有以下数据：
```
id
--
10
12
14
```

现在开启事务A，此时执行一条`锁定读取`的查询`select id from TA where id > 11 for update`，我们可以得到结果：

```
id
--
12
14
```

此时另一个事务提交了一条`id=13`的记录，事务A中再次执行同样的查询，得到的结果如下：

```
id
--
12
13
14
```

可以看到在同一个事务中，即使使用了锁定读取，仍旧会读到不同的结果，这是因为当前隔离级别禁用了间隙锁定，数据库仅会锁定`id=12、14`的两行数据，而允许在其中插入新的数据。

这种情况就被称为幻读。

### 可重复读与不可重复读

这一节标题可能有点魔幻。`可重复读`是指当前的隔离级别，而`不可重复读`是当前级别会导致的某种特殊问题。

上一节说到了幻读，为了解决幻读问题，就需要引入可重复读的隔离级别。

已经说到了导致幻读的原因是禁用了间隙锁定，那么很自然的，若要解决幻读问题，就要使用间隙锁定。

首先，对于一致的非锁定读取，当前级别的第一次查询会创建一个新的快照。

对于锁定读取，当前级别会进行间隙锁定，实现上是通过`Next-Key Locks或者Gap Locks`来实现的，具体的细节会在后面详细描述。

仍旧以上一节中的查询案例为例：`select id from TA where id > 11 for update`，数据库会锁定`id>11`的所有数据位置，即禁止插入`id>11`的数据。

在本级别中，具体是否使用间隙锁定，由查询语句的查询条件决定。若是使用唯一索引指定的数据，则仅锁定当前记录，否则就会使用间隙锁定来锁定该查询覆盖的全部范围。

### 序列化
